// API endpoint for executing scheduled prompts with @mention data resolution
import { Request, Response } from 'express';
import type { NextApiRequest, NextApiResponse } from 'next'
import { DatabasePool } from '../../lib/database-pool';
import OpenAI from 'openai'
import { Resend } from 'resend'

// Initialize OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})

// Initialize Resend
const resend = new Resend(process.env.RESEND_API_KEY)

async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' })
  }

  let client = null
  
  try {
    const { prompt_id, user_email } = req.body

    if (!prompt_id) {
      return res.status(400).json({ error: 'prompt_id is required' })
    }

    const dbPool = DatabasePool.getInstance()

    client = await DatabasePool.getClient()

    // Get the scheduled prompt
    const promptResult = await client.query(
      'SELECT * FROM scheduled_prompts WHERE id = $1 AND is_active = true',
      [prompt_id]
    )

    if (promptResult.rows.length === 0) {
      client.release()
      return res.status(404).json({ error: 'Scheduled prompt not found' })
    }

    const prompt = promptResult.rows[0]
    
    // Parse mentioned data types
    const mentionedDataTypes = typeof prompt.data_types === 'string'
      ? JSON.parse(prompt.data_types)
      : prompt.data_types || []

    // Simulate @mention data resolution
    const mentionData = await resolveMentionData(mentionedDataTypes, prompt.user_email, client)

    // Process with OpenAI
    const systemPrompt = `You are a health AI assistant processing a scheduled prompt. The user has requested analysis of their health data with specific @mentions.

Available health data:
${JSON.stringify(mentionData, null, 2)}

Please provide a comprehensive analysis based on the user's prompt and the available data.`

    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: prompt.prompt_text }
      ],
      max_tokens: 1000,
      temperature: 0.7
    })

    const aiResult = response.choices[0].message.content

    // Log the execution
    const executionTime = new Date().toISOString()
    await client.query(`
      INSERT INTO prompt_executions (prompt_id, user_id, executed_at, ai_response, result, success, execution_status, data_sources_used)
      VALUES ($1, $2, CURRENT_TIMESTAMP, $3, $4, true, 'completed', $5)
    `, [prompt_id, prompt.user_id, aiResult, aiResult, JSON.stringify(mentionedDataTypes)])

    // Send email if email delivery is enabled
    let emailResult = null
    if (prompt.email_delivery && prompt.user_email) {
      console.log(`Sending email to ${prompt.user_email} for prompt: ${prompt.title}`)
      
      try {
        const formattedTime = new Date(executionTime).toLocaleString()
        const dataTypes = Object.keys(mentionData).join(', ') || 'None'
        
        const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scheduled Health Analysis Results</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }
    .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px 20px; text-align: center; border-radius: 10px 10px 0 0; }
    .content { background: #ffffff; padding: 30px; border: 1px solid #e1e5e9; border-top: none; }
    .result-box { background: #f8f9fa; border-left: 4px solid #667eea; padding: 20px; margin: 20px 0; border-radius: 4px; }
    .data-summary { background: #e3f2fd; padding: 15px; border-radius: 6px; margin: 15px 0; }
    .footer { background: #f8f9fa; padding: 20px; text-align: center; font-size: 14px; color: #6c757d; border-radius: 0 0 10px 10px; }
    .logo { font-size: 24px; font-weight: bold; margin-bottom: 10px; }
    .timestamp { font-size: 14px; color: #e1e5e9; }
    h2 { color: #667eea; margin-top: 25px; }
  </style>
</head>
<body>
  <div class="header">
    <div class="logo">üè• Treatment AI</div>
    <h1>Scheduled Health Analysis</h1>
    <div class="timestamp">Generated on ${formattedTime}</div>
  </div>
  
  <div class="content">
    <h2>üìã Prompt: ${prompt.title}</h2>
    
    <div class="data-summary">
      <strong>üìä Data Sources Analyzed:</strong> ${dataTypes}
    </div>
    
    <div class="result-box">
      <h3>ü§ñ AI Analysis Results</h3>
      ${(aiResult || 'No analysis available').replace(/\n/g, '<br>')}
    </div>
    
    <h2>üí° About This Analysis</h2>
    <p>This analysis was generated by Treatment AI using your scheduled prompt and current health data. The insights are based on the information available at the time of execution.</p>
    
    <p><strong>‚ö†Ô∏è Important:</strong> This analysis is for informational purposes only and should not replace professional medical advice. Always consult with healthcare providers for medical decisions.</p>
  </div>
  
  <div class="footer">
    <p>Powered by our Global Library of Medicine‚Ñ¢</p>
    <p>¬© 2025 Treatment AI - Advancing Healthcare Through AI</p>
  </div>
</body>
</html>`

        const response = await resend.emails.send({
          from: 'noreply@opinions.doctor',
          to: prompt.user_email,
          subject: `Scheduled Health Analysis: ${prompt.title}`,
          html: htmlContent
        })

        emailResult = {
          success: true,
          messageId: response.data?.id
        }
      } catch (error: any) {
        console.error('Email sending failed:', error)
        emailResult = {
          success: false,
          error: error.message
        }
      }
    }

    res.status(200).json({
      success: true,
      prompt_id,
      result: aiResult,
      mentioned_data: mentionData,
      execution_time: executionTime,
      email_sent: emailResult?.success || false,
      email_message_id: emailResult?.messageId
    })

  } catch (error: any) {
    console.error('Error executing scheduled prompt:', error)
    res.status(500).json({
      success: false,
      error: error.message,
      timestamp: new Date().toISOString()
    })
  } finally {
    // Always release the database connection
    if (client) {
      client.release()
    }
  }
}

// Simulate @mention data resolution
async function resolveMentionData(mentionedDataTypes: string[], userEmail: string, client: any) {
  const data: any = {}

  for (const dataType of mentionedDataTypes) {
    switch (dataType) {
      case 'oura-ring':
      case 'wearables':
        data.wearables = {
          steps: 8432,
          sleep_hours: 7.2,
          heart_rate_avg: 68,
          calories_burned: 2340,
          last_sync: '2025-07-03T18:00:00Z'
        }
        break
      
      case 'medications':
        data.medications = [
          {
            name: 'Vitamin D3',
            dosage: '2000 IU',
            frequency: 'Daily',
            last_taken: '2025-07-03T08:00:00Z'
          },
          {
            name: 'Magnesium',
            dosage: '400mg',
            frequency: 'Daily',
            last_taken: '2025-07-03T20:00:00Z'
          }
        ]
        break
      
      case 'health_data':
      case 'vitals':
        data.vitals = {
          blood_pressure: '120/80',
          weight: '160 lbs',
          body_temperature: '98.6¬∞F',
          recorded_date: '2025-07-03T06:00:00Z'
        }
        break
      
      case 'lab_results':
        data.lab_results = [
          {
            test: 'Complete Blood Count',
            result: 'Normal ranges',
            date: '2025-06-28T10:00:00Z'
          },
          {
            test: 'Lipid Panel',
            result: 'Cholesterol: 180 mg/dL (Normal)',
            date: '2025-06-28T10:00:00Z'
          }
        ]
        break
      
      default:
        data[dataType] = {
          message: `Data for ${dataType} would be retrieved from the appropriate service`,
          timestamp: new Date().toISOString()
        }
    }
  }

  return data
}

export default async function expressAdapter(req: Request, res: Response) {
  return await handler(req as any, res as any);
}